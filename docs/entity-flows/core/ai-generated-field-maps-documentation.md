# Field Maps in Nama ERP - Complete Guide (AI-Generated by Claude.ai)

## Overview

Field maps are a powerful feature in Nama ERP that allow automatic copying and transformation of data between different entities (records). This system is primarily used in Entity Flows to generate new documents from existing ones (e.g., creating a Credit Note from a Sales Invoice).

## Basic Concept

A field map is a set of instructions that tells the system:
- **What data to copy** (source field)
- **Where to copy it** (target field)
- **How to transform it** (optional functions)

The basic syntax is:
```
targetField=sourceField
```

## Simple Field Mapping

### Direct Field Copy
The simplest form copies a value from one field to another:

```ini
code=code                  # Copy code from source to target
description=description    # Copy description from source to target
customer=customer          # Copy customer reference from source to target
```

### Setting Fixed Values
You can set fields to specific values:

```ini
status="Active"           # Set status to the text "Active"
priority=1                # Set priority to number 1
isApproved=true          # Set boolean value
discount=null            # Clear the field
```

### Downloading Files from URLs (Attachments)
For attachment fields (LargeData type), you can provide a URL and the system will automatically download the file:

```ini
# Direct URL - downloads and stores the file
attachment="https://example.com/files/sample.pdf"

# URL from another field
attachment2=productImageURL

# Download contract document from customer website
contractFile=customer.contractDocumentURL

# Download image from product catalog
productImage=item.imageURL
```

::: tip How URL Download Works
When you set an attachment field to a URL (any string containing `://`), the system:
1. Detects it's a URL and initiates an HTTP GET request
2. Downloads the file content from the URL
3. Extracts the filename from the `Content-Disposition` header or URL path
4. Stores the file data in the LargeData field
5. If the field already has an attachment, it updates it instead of creating a new one
:::

::: warning URL Requirements
- URLs must be accessible via HTTP/HTTPS
- No authentication is performed (URL must be publicly accessible or include auth tokens in the URL)
- Failed downloads are logged but won't stop the field map execution
- Large files may impact performance - use cautiously
:::

### Special References
```ini
ref5=$this               # Set ref5 to reference the source entity itself
fromDocument=$this       # Create a link back to the source document
```

## Working with Collections (Detail Lines)

### Copying Entire Tables
When documents have detail lines (like invoice items), you can:

```ini
details=[lines]          # Create same number of lines as source
details=[5]              # Create exactly 5 empty lines
details=[clear]          # Remove all existing lines
```

### Adding Lines
```ini
details=[addLines(5)]              # Add 5 new empty lines
details=[addLines(lines)]          # Add same number as source lines
details1=[addLines(details2)]      # Add lines based on another collection
```

### Copying Field Values to All Lines
```ini
details.warehouse=warehouse        # Copy header warehouse to all detail lines
details.project=project           # Copy header project to all detail lines
```

### Line-by-Line Copying
```ini
details.quantity=lines.quantity    # Copy quantity from each source line
details.price=lines.unitPrice      # Copy price from corresponding lines
details.item=lines.item           # Copy item references
```

## Advanced Functions

### Text Manipulation

#### Masking
Format text according to a pattern:
```ini
altCode=mask(code,XXX-XXX-XXX)    # ABC123456 becomes ABC-123-456
phoneDisplay=mask(phone,XXXX XXX XXXX)  # 0501234567 becomes 0501 234 567
```
- `X` represents a character from the original value
- Any other character (like `-`, `.`, ` `) is inserted as-is

#### Text Extraction
```ini
firstFive=description.$left_5      # Get first 5 characters
lastTwo=code.$right_2             # Get last 2 characters
middle=ref1.$mid_3_4              # Get 4 characters starting at position 3
```

### Mathematical Functions

#### Totaling Values
Calculate sum of values in detail lines:
```ini
totalAmount=totalize(details,details.price)
netTotal=totalize(lines,lines.netAmount)
```

#### Conditional Totaling
Sum values only when a condition is met:
```ini
serviceTotal=totalizeif(details,details.price,select case when {details.item.item.itemType} = 'Service' then 1 else 0 end)
```

#### SQL-Based Calculations
```ini
weightedTotal=totalizesql(select {details.quantity} * {details.unitPrice} * {details.discount} / 100)
```

### Database Queries

#### Simple SQL Queries
```ini
customerBalance=sql(select balance from Customer where id = {customer.id})
lastInvoiceDate=sql(select max(valueDate) from SalesInvoice where customer_id = {customer.id})
```

#### Multi-line SQL
```ini
complexValue=mlsql(
  select case 
    when {totalAmount} > 1000 then 'High'
    when {totalAmount} > 500 then 'Medium'
    else 'Low'
  end
)endmlsql
```

### Conditional Value Selection

#### First Not Empty
Returns the first value that is not empty:
```ini
details.ref1=firstNotEmpty(details.ref1,ref1,customer.ref1)
contactPhone=firstNotEmpty(customer.mobile,customer.phone,customer.contact.phone)
```

#### First Not Null
Returns the first value that is not null:
```ini
details.project=firstNotNull(details.project,project,customer.defaultProject)
```

### Reference Creation
Create references to other entities:
```ini
# Fixed reference
relatedInvoice=ref("SalesInvoice","SIV150160")

# Dynamic reference based on SQL
parentDoc=ref(ref2.entityType,sql(select id from SalesInvoice where code = {ref1}))
```

## Advanced Line Matching

### Match Lines By Fields
Match source and target lines based on specific fields:
```ini
matchLinesBy=details.item.item=lines.ref1,details.warehouse=lines.warehouse(
  details.quantity=lines.quantity
  details.price=lines.unitPrice
  details.discount=lines.discount
)endMatchLinesBy
```

This will:
1. Match lines where item and warehouse are the same
2. Only copy data between matched lines
3. Ignore unmatched lines

### Filter Lines
Process only specific lines based on conditions:
```ini
filterLinesBy=(
  filterSourceDetail=details
  filterSourceBy=sql(select case when {details.quantity} > 0 then 1 else 0 end)
  filterTargetDetail=lines
  filterTargetBy=sql(select case when {lines.item.item.isActive} = 1 then 1 else 0 end)
  
  # Copy only between filtered lines
  lines.quantity=details.quantity
)endFilterLinesBy
```
You can filter source only, target only, or both
## Tempo Expression Integration

### Single-Line Tempo Expressions
Field maps support embedded Tempo expressions for dynamic text generation and complex field calculations:

```ini
# Basic tempo field reference
customerInfo=tempo(Customer {customer.name1} has code {customer.code})

# Format with date functions
processedInfo=tempo(Processed by {$user.name2} on {$today})

# Conditional content
statusMessage=tempo({if(status)}Active since {valueDate}{else}Not active{endif})

# Links and hyperlinks
customerLink=tempo({link(customer)})

# Calculations and totals
summaryText=tempo(Total amount: {money.netValue}, Customer: {customer.name1})
```

### Multi-Line Tempo Expressions
For complex tempo templates with multiple lines, loops, or detailed formatting:

```ini
# Complex customer summary
customerSummary=mltempo(
Customer Details:
- Name: {customer.name1}
- Code: {customer.code}
- Balance: {customer.n1}
)endmltempo

# Invoice details with table
invoiceDetails=mltempo(
Invoice Summary for {customer.name1}

{opentable}
{row}{cell}Item{cell}Quantity{cell}Price{cell}Total{endrow}
{loop(details)}
  {row}
    {cell}{details.item.item.name1}
    {cell}{details.quantity.quantity.primeQty.value}
    {cell}{details.price.unitPrice}
    {cell}{details.price.netValue}
  {endrow}
{endloop}
{closetable}

Total Amount: {money.netValue}
)endmltempo

# Conditional content with complex logic
approvalMessage=mltempo(
{if(currentApprovalCase.state)}
  {if=(currentApprovalCase.state,"Approved")}
    ✅ Approved by {currentApprovalCase.lastStep.actualResponsible.name1} on {currentApprovalCase.currentApprovalCase.completionDate}
    {if(currentApprovalCase.lastStep.approvalComment)}
      Comment: {currentApprovalCase.lastStep.approvalComment}
    {endif}
  {else}
    ❌ Status: {translate(currentApprovalCase.state)}
  {endif}
{else}
  ⏳ Pending approval
{endif}
)endmltempo
```

## Special Operations

### Switch Target/Source

When working with collections (detail lines) in referenced entities, you need to use special syntax to properly access and modify fields.

#### Working with Header Fields in Referenced Entities

For header fields in referenced entities, you can use direct dot notation:

```ini
# This works - modifying a header field in customer
customer.n1="5"
```

#### The Problem with Collections in Referenced Entities

However, when you need to work with collections (details) inside referenced entities, the simple dot notation doesn't work:

```ini
# ❌ This will NOT work as expected
customer.lines.n1=n1
```

This is where `switchTarget` and `switchSource` become essential.

#### Using switchTarget - Modifying Collections in Referenced Entities

Use `switchTarget` when you need to **modify fields in collections** within a referenced entity:

```ini
# ✅ Correct way to modify collections in customer object
switchTarget=customer(
  lines.n1=n1
)endSwitchTarget
```

::: tip
Notice that inside `switchTarget`, we omit the `customer.` prefix because we're already working inside the customer context.
:::

**More Examples:**

```ini
# Update related document details
switchTarget=relatedDocument(
  # Now copying TO each related document's collections
  status="Processed"
  processedBy=currentUser
  processedDate=sql(select getdate())

  # Working with collections inside the related document
  details.processed=true
  details.processedDate=sql(select getdate())
)endSwitchTarget
```

#### Using switchSource - Copying from Collections in Referenced Entities

Use `switchSource` when you need to **copy data FROM collections** within a referenced entity TO collections in the current entity:

```ini
# ❌ This will NOT work as expected
details.n1=customer.lines.n1

# ✅ Correct way to copy from customer collections to invoice collections
switchSource=customer(
  details.n1=lines.n1
  details.item=lines.item
  details.quantity=lines.quantity
)endSwitchSource
```

::: tip
Inside `switchSource`, the left side (target) refers to the current entity's collections, and the right side (source) refers to the referenced entity's collections without the prefix.
:::

**More Examples:**

```ini
# Copy data from a nested reference
switchSource=customer.ref1(
  totalPurchases=n5  # n5 here will come from customer.ref1
  lastOrderDate=date1
)endSwitchSource

# Copy from supplier collections to purchase order
switchSource=supplier(
  details.defaultPrice=priceList.price
  details.leadTime=priceList.deliveryDays
)endSwitchSource
```

#### Working with Generic References ($toReal)

When working with generic reference fields (like `fromDoc` which can point to different entity types), you normally need to use `$toReal` to access the actual entity. However, `switchSource` and `switchTarget` handle this automatically:

```ini
# ❌ This will NOT work as expected
details=fromDoc.$toReal.details
details.text1=fromDoc.$toReal.details.description

# ✅ Correct way - $toReal is handled automatically
switchSource=fromDoc(
  details=[details]
  details.text1=details.description
)endSwitchSource
```

::: tip
Notice that we do **not** need `$toReal` inside `switchSource` and `switchTarget`. Generic references are automatically resolved to their real entity type within the switch context.
:::

**Why this works:**
- Outside the switch: `fromDoc` is a generic reference that needs `$toReal` to access actual data
- Inside the switch: The system automatically resolves `fromDoc` to its real entity type
- You can directly access collections and fields without the `$toReal` operator

#### When to Use Each

| Scenario | Syntax |
|----------|--------|
| Modify header field in referenced entity | `customer.n1="5"` |
| Modify collection in referenced entity | `switchTarget=customer(lines.n1=n1)endSwitchTarget` |
| Copy from collection in referenced entity | `switchSource=customer(details.n1=lines.n1)endSwitchSource` |

#### Applicability

These `switchTarget` and `switchSource` features work in:
- **Entity Flows** (Business process automation)
- **GUI Post Actions** (Field change handlers)

::: warning
Always remember to use `endSwitchTarget` and `endSwitchSource` to close the switch block. Missing these will cause syntax errors.
:::

### Working with Newly Added Lines
```ini
details=[addLines(5)]
details=addedLinesOnly(details.item=defaultItem)
details=addedLinesOnly(details.quantity=1)
details=addedLinesOnly(details.price=defaultPrice)
```

### Line Selection
```ini
selectLine="details(0)"     # Select first line (0-based index)
$line.quantity=10          # Set quantity of selected line

selectLine="details(2)"     # Select third line
$line.price=sql(select {$line.quantity} * {$line.unitPrice})  # Calculate price

selectLine="details(last)"  # Select last line
$line.isLast=true
```

### Entity Commands
```ini
runCommand="edit"                          # Start editing mode
runCommand="save"                          # Save the entity
runCommand="recommit"                      # Re-save/recommit the entity
runCommand="forcestable"                   # Force update without validation
runCommand="unforcestable"                 # Cancel force update mode
runCommand="flush"                         # Flush database changes
runCommand="guessPeriod"                   # Auto-detect accounting period (DocumentFile only)
runCommand="makeValueDateToday"            # Set value date to today (DocumentFile only)
runCommand="setCodeIfNeeded"               # Set code from book or group
runCommand="copyDimensionsFromBookOrGroup"     # Copy Dimensions (legal entity, branch, department, analysis set, and branch) from book or group
runCommand="systemUpdateCalculatedFields"  # Update all calculated fields
runCommand="regenledger"                   # Regenerate ledger entries (if applicable)
runCommand="runManualEntityFlow(EF005)"    # Run specific entity flow by code
runCommand="encryptPassword"               # Encrypt password field (NaMaUser only)
runCommand="doNotCheckQty"                 # Skip quantity checks (InvoiceWithStockEffect only)
runCommand="collectStockDocsIfEmpty"       # Collect stock documents (InvoiceWithStockEffect only)
```

### Updating Related Entities
```ini
# Update item from within invoice line
details.item.item.runCommand="edit"
details.item.item.lastSaleDate=valueDate
details.item.item.lastSalePrice=details.price
details.item.item.runCommand="save"
```

## Security Features

### Encryption/Decryption
```ini
# Encrypt sensitive data
encryptedCode=code.$encrypt1
encryptedSSN=customer.ssn.$encrypt2

# Decrypt when needed
originalCode=encryptedCode.$decrypt1
originalSSN=encryptedSSN.$decrypt2
```

### OTP Generation
```ini
# Numeric OTP
otp4Digit=$createNumericOTP4     # e.g., 1234
otp6Digit=$createNumericOTP6     # e.g., 123456

# Alphanumeric OTP
otpCode=$createOTP4              # e.g., A1B2
otpLong=$createOTP8              # e.g., A1B2C3D4
```

## Best Practices

### 1. Order Matters
Fields are processed in order, so dependent fields should come after their dependencies:
```ini
# Correct
subtotal=totalize(details,details.price)
tax=sql(select {subtotal} * 0.15)
total=sql(select {subtotal} + {tax})

# Incorrect (total calculated before tax)
total=sql(select {subtotal} + {tax})
subtotal=totalize(details,details.price)
tax=sql(select {subtotal} * 0.15)
```


### 2. Handle Empty Values
```ini
# Ensure a value is always set
warehouse=firstNotEmpty(details.warehouse,defaultWarehouse,"WH001")
```

### 3. Test Conditions
When using SQL conditions, test with simple cases first:
```ini
# Start simple
includeInTotal=sql(select 1)

# Then add complexity
includeInTotal=sql(select case when {item.itemType} = 'Service' then 1 else 0 end)
```

## Troubleshooting

### Common Errors

1. **"Field not found"** - Check field spelling and entity structure
2. **"Type mismatch"** - Ensure compatible data types (use ref() for references)
3. **"Empty result"** - Check SQL queries return data
4. **"Index out of bounds"** - Verify line numbers exist

### Debugging Tips

1. Start with simple direct copies
2. Test SQL queries separately
3. Use fixed values to isolate issues
4. Check entity relationships are correct
5. Verify user permissions for all operations

---

*This documentation was generated by Claude.ai based on analysis of the Nama ERP source code and system functionality.*